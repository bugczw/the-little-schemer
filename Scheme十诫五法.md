## _Scheme_十诫:  
1. _第一诫:_
    * 当对一个原子列表_lat_进行递归调用时，询问两个有关_lat_的问题:_(null? lat)_和__else__。
    * 当对一个数字_n_进行递归调用时，询问两个有关_n_的问题:_(zero? n)_和__else__。
    * 当对一个__S__-表达式列表l进行递归调用时，询问三个有关l的问题:_(null? l)_、_(atom? (car l))_和__else__。

2. _第二诫:_
    * 使用_cons_来构建列表

3. _第三诫:_
    * 构建列表的时候，描述第一个典型元素，之后_cons_该元素到一般性递归_(natural recursion)_上。

4. _第四诫:_
    * 在递归时总是改变至少一个参数:
	    * 当对一个原子列表_lat_进行递归调用时，使用_(cdr lat)_。
		* 当对数字_n_进行递归调用时，使用_(sub1 n)_。
		* 当对一个__S__-表达式进行递归调用时，只要是_(null? l)_和_(atom? (car l))_都不为_true_，那么就同时使用_(cdr l)_和_(car l)_。
    * 在递归时改变的参数，必须向着不断接近结束条件而改变。改变的参数必须在结束条件中得以测试:
	    * 当使用_cdr_时，用_null?_测试是否结束。
		* 当使用_sub1_时，用_zero?_测试是否结束。

5. _第五诫:_
    * 当用_o+_构建一个值时，总是使用0作为结束代码行的值，因为加上0不会改变加法的值。
    * 当用_o*_构建一个值时，总是使用1作为结束代码行的值，因为乘以1不会改变乘法的值。
	* 当用_cons_构建一个值时，总是考虑把_()_作为结束代码行的值。

6. _第六诫:_
    * 简化工作只在功能正确之后开展。

7. _第七诫:_
    * 对具有相同性质的_subparts_(子部件)进行递归调用：
	    * 列表的子列表。
		* 算术表达式的子表达式。

8. _第八诫:_
    * 使用辅助函数来抽象表达方式。

9. _第九诫:_
    * 用函数来抽象通用模式。

10. _第十诫:_
    * 构建函数，一次收集多个值。

	
	
	
## _Scheme_五法:
1. _第一法:_
    * 基本元件_car_仅定义为针对非空列表。

2. _第二法:_
    * 基本元件_cdr_仅定义为针对非空列表。任意非空列表的_cdr_总是另一个列表。

3. _第三法:_
    * 基本元件_cons_需要两个参数。第二个参数必须是一个列表。结果是一个列表。

4. _第四法:_
    * 基本元件_null?_仅定义为针对列表。

5. _第五法:_
    * 基本元件_eq?_需要两个参数。每个参数都必须需是一个非数字的原子。